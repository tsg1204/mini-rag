<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Writing Defensive Javascript</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Writing Defensive Javascript</h1>
</header>
<section data-field="subtitle" class="p-summary">
You hear a lot of programmers joke about JavaScript not being a ‚Äúreal‚Äù programming language. Besides not having a Class based system of‚Ä¶
</section>
<section data-field="body" class="e-content">
<section name="7385" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0261" id="0261" class="graf graf--h3 graf--leading graf--title">Writing Defensive JavaScript</h3><figure name="6593" id="6593" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*PzXoT0E8j74N2YBv.jpg" data-width="1280" data-height="720" src="https://cdn-images-1.medium.com/max/800/0*PzXoT0E8j74N2YBv.jpg"></figure><h4 name="fd2b" id="fd2b" class="graf graf--h4 graf-after--figure">You hear a lot of programmers joke about JavaScript not being a ‚Äúreal‚Äù programming language.</h4><p name="dd13" id="dd13" class="graf graf--p graf-after--h4">Besides not having a Class based system of inheritance, JS is also dynamically typed unlike C#, Java, Scala‚Ä¶ you know, all those real programming languages. But the speed, flexibility and ease of use are what led us to write JS! Types be damned!</p><p name="820f" id="820f" class="graf graf--p graf-after--p">Of course there is a cost to the flexibility that JS offers, some of which may be negated if you‚Äôre using Typescript, but using the following defense tactics while writing code can save you a pesky bug down the road (that also rhymes so you know it‚Äôs true üòâ).</p><h3 name="bf59" id="bf59" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">Use Default¬†Params</strong></h3><p name="2770" id="2770" class="graf graf--p graf-after--h3">If you have a function which depends on an argument being present and being of a certain type then you should consider using default parameters in your function‚Äôs signature.</p><pre name="ded6" id="ded6" class="graf graf--pre graf-after--p">const addNameToNameArray = (name, nameArray) =&gt; {<br>  if(name.length){<br>   nameArray.push(name)<br>  }<br>  return nameArray<br>}</pre><p name="b61b" id="b61b" class="graf graf--p graf-after--pre">Simple enough right? We take a name and a name array and then simply add the name to the array if one is present. We are making some assumptions here however that the name will be of a type that has a <code class="markup--code markup--p-code">length</code> property and that our <code class="markup--code markup--p-code">nameArray</code> will be, well, an array. If either one of these conditions is not met, we will fail spectacularly.</p><pre name="5899" id="5899" class="graf graf--pre graf-after--p">const addNameToNameArray = (name = &#39;&#39;, nameArray = []) =&gt; {<br>  if(name.length){<br>   nameArray.push(name)<br>  }<br>  return nameArray<br>}</pre><p name="9705" id="9705" class="graf graf--p graf-after--pre">Ahh, much better. Now we can sleep at night, knowing this useless function won‚Äôt break production once it‚Äôs deployed if it‚Äôs called with a missing argument.</p><h3 name="19a7" id="19a7" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">Using An Object as an¬†Argument</strong></h3><p name="2a3e" id="2a3e" class="graf graf--p graf-after--h3">Your team had this nice little function that accepted 3 arguments and did some straightforward logic with it to fetch some data from a third party service. But that was the past, now this little function is nearly unrecognizable and has a whopping 6 arguments getting passed to it. Now, usually an argument with more than, I don‚Äôt know, let‚Äôs say 3 arguments would be a code smell, but there are times you can‚Äôt avoid it.</p><pre name="61d0" id="61d0" class="graf graf--pre graf-after--p">const createUser = (name, date, profileId, dataId, dataType, apiKey) =&gt; {<br>  const user = {<br>   name,<br>   profileId<br>  };</pre><pre name="bafc" id="bafc" class="graf graf--pre graf-after--pre">  const formattedDate = moment(date).unix();<br>  thirdPartyAPI.fetch(user, formattedDate, dataId, dataType, apiKey)<br>}</pre><pre name="4131" id="4131" class="graf graf--pre graf-after--pre">createUser(&#39;Bob&#39;, &#39;04/20/20&#39;, 1, 123, 1234, &#39;story&#39;, &#39;abc123&#39;)</pre><p name="899c" id="899c" class="graf graf--p graf-after--pre">The danger in functions like these are that the order of the arguments matters and if any of them are incorrect, we risk blowing up our API call. More arguments, means more surface area to make mistakes. It‚Äôs nearly inevitable that some developer will call this function and the <code class="markup--code markup--p-code">profileId</code> will be in the place of the <code class="markup--code markup--p-code">dataId</code>¬†. Now this won‚Äôt blow up your program as they are both likely numbers or strings, but their incorrect order will give you the wrong data from the API or worse, just not work.</p><pre name="83dc" id="83dc" class="graf graf--pre graf-after--p">const createUser = ({name, date, profileId, dataId, dataType, apiKey}) =&gt; {<br>  const user = {<br>   name,<br>   profileId<br>  };</pre><pre name="e547" id="e547" class="graf graf--pre graf-after--pre">const formattedDate = moment(date).unix();<br>  thirdPartyAPI.fetch(user, formattedDate, dataId, dataType, apiKey)<br>}</pre><pre name="ee18" id="ee18" class="graf graf--pre graf-after--pre">createUser({<br>  name: &#39;Bob&#39;,<br>  date: &#39;04/20/20&#39;,<br>  profileId: 1,<br>  dataId: 123,<br>  dataType: &#39;story&#39;<br>  apiKey: &#39;123abc&#39;<br>})</pre><p name="ac39" id="ac39" class="graf graf--p graf-after--pre">Boom. Using an object, we actually place less cognitive load on our fellow developers and make sure that our arguments are explicitly set. For functions with more than 4 arguments, I feel like using an object is a must.</p><h3 name="ad1e" id="ad1e" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">Optional Chaining</strong></h3><p name="0fde" id="0fde" class="graf graf--p graf-after--h3">We deal a lot with objects in JavaScript. Many people famously, and wrongly, say that everything in JavaScript is an object. Well, that‚Äôs not quite true, but we do end up working with them and their properties often and digging out the useful info can be a pain and a bit dangerous if you‚Äôre not careful.</p><pre name="c700" id="c700" class="graf graf--pre graf-after--p">const hat = user.outfit.hat;</pre><p name="7327" id="7327" class="graf graf--p graf-after--pre">Harmless right? Well, if our user object doesn‚Äôt have an <code class="markup--code markup--p-code">outfit</code> property or that property is <code class="markup--code markup--p-code">undefined</code> then we will have an issue on our hands.</p><pre name="858c" id="858c" class="graf graf--pre graf-after--p">TypeError: Cannot read property &#39;hat&#39; of undefined</pre><p name="ab1f" id="ab1f" class="graf graf--p graf-after--pre">Now, the first step in making sure we don‚Äôt get this error is to check at each level whether the next property exists, and we get stuck writing unsexy code like this</p><pre name="015a" id="015a" class="graf graf--pre graf-after--p">const hat = user &amp;&amp; user.outfit &amp;&amp; user.outfit.hat || &#39;hat&#39;;</pre><p name="ff5a" id="ff5a" class="graf graf--p graf-after--pre">We feel a little sad writing this and a whole hell of a lot less sexy. Thankfully, with the power of Babel, JS developers can take advantage of what Ruby and Coffeescript developers have had for years: optional chaining</p><pre name="7e50" id="7e50" class="graf graf--pre graf-after--p">const hat = user?.outfit?.hat || &#39;hat&#39;</pre><p name="777d" id="777d" class="graf graf--p graf-after--pre">Mmmmm, satisfying. Now if our traversal fails at any point, our operation will short-circuit and return <code class="markup--code markup--p-code">undefined</code>. The code is both safer and more readable.</p><h3 name="8e34" id="8e34" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">The Best Offense is Good¬†Defense</strong></h3><p name="5f8a" id="5f8a" class="graf graf--p graf-after--h3 graf--trailing">To me, a lot of writing defensive JavaScript is simply putting up logical safeguards to protect your code from input you might not expect, but will accept. Hopefully some of these suggestions will prevent you from being woken up at 3am on a Saturday morning to fix a bug in production!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@brianjenney" class="p-author h-card">Brian Jenney</a> on <a href="https://medium.com/p/c6d42940d30f"><time class="dt-published" datetime="2020-06-26T14:07:48.133Z">June 26, 2020</time></a>.</p><p><a href="https://medium.com/@brianjenney/writing-defensive-javascript-c6d42940d30f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 30, 2025.</p></footer></article></body></html>