<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Using object-mapper to Format Your API Data and Maintain Consistency</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Using object-mapper to Format Your API Data and Maintain Consistency</h1>
</header>
<section data-field="subtitle" class="p-summary">
As a full stack or front end JS developer, you’re going to find yourself spending a lot of time dealing with objects returned from an API…
</section>
<section data-field="body" class="e-content">
<section name="8e7e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5928" id="5928" class="graf graf--h3 graf--leading graf--title">Using object-mapper to Format Your API Data and Maintain Consistency</h3><figure name="e9ac" id="e9ac" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*_3EZPMpxGK1iGzmSEsdNXQ.jpeg" data-width="806" data-height="476" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*_3EZPMpxGK1iGzmSEsdNXQ.jpeg"></figure><p name="0ac0" id="0ac0" class="graf graf--p graf-after--figure">As a full stack or front end JS developer, you’re going to find yourself spending a lot of time dealing with objects returned from an API that you will need to format to an interface that your front end expects. Maybe you are using a third party API that returns JSON data in kebab_case or has dates that are in some godawful format or proper names that aren’t capitalized, or maybe your backend team has recently updated the database to use new field names or changed old values to a new format.</p><p name="9c04" id="9c04" class="graf graf--p graf-after--p">Now you have the choice of updating all your front end code which relies on legacy naming conventions and expects certain values or having your API maintain consistency by formatting the data before passing it off to the front end… I’ll choose working with the API over the error prone method of updating all my front end code any day.</p><p name="6516" id="6516" class="graf graf--p graf-after--p">You always have the option of rolling your own formatter function which can take in an object and return its new and improved version. This will likely involve deleting keys, reassigning properties as well as helper functions to transform the object values. Rolling your own has the benefit of giving you granular control but comes with the cost of maintaining the logic and testing the functionality.</p><p name="0ad4" id="0ad4" class="graf graf--p graf-after--p">Luckily there’s a simple library which handles this common task of transforming object values and keys: <a href="https://www.npmjs.com/package/object-mapper" data-href="https://www.npmjs.com/package/object-mapper" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">object-mapper</a>. This package makes formatting an array of objects pretty trivial:</p><p name="546b" id="546b" class="graf graf--p graf-after--p">First let’s install the package — <code class="markup--code markup--p-code">npm install object-mapper</code></p><pre name="2221" id="2221" class="graf graf--pre graf-after--p">const mapper = require(&#39;object-mapper&#39;)</pre><pre name="7a52" id="7a52" class="graf graf--pre graf-after--pre">//our mapper <br>const map = {<br>  &quot;created_at&quot;: { //old key<br>    key: &quot;createdAt&quot;, //the key we want to use<br>    transform: (val) =&gt; { <br>      return new Date(val).toString()<br>    }<br>  },<br>  &quot;user_name&quot;: {<br>    key: &quot;userName&quot;,<br>    transform: (val) =&gt; {<br>      return `${val[0].toUpperCase()}${val.slice(1)}`;<br>    }<br>  },<br>  &quot;story_body&quot;: &quot;storyBody&quot;<br>};</pre><pre name="7c63" id="7c63" class="graf graf--pre graf-after--pre">//our raw data<br>const data = [<br>  {<br>    created_at: &#39;12/25/2019&#39;,<br>    user_name: &#39;alex&#39;,<br>    story_body: &#39;random story&#39;<br>  },<br>  {<br>    created_at: &#39;12/28/2019&#39;,<br>    user_name: &#39;jimbo&#39;,<br>    story_body: &#39;another random story&#39;<br>  }<br>];</pre><pre name="bb52" id="bb52" class="graf graf--pre graf-after--pre">//lets transform the data<br>const transformedData = data.map((datum) =&gt; mapper(datum, map))</pre><pre name="b694" id="b694" class="graf graf--pre graf-after--pre">//outcome<br>[<br>  {<br>    createdAt: &#39;Wed Dec 25 2019 00:00:00 GMT+0000 (Coordinated Universal Time)&#39;,<br>    userName: &#39;Alex&#39;,<br>    storyBody: &#39;random story&#39;<br>  },<br>  {<br>    createdAt: &#39;Sat Dec 28 2019 00:00:00 GMT+0000 (Coordinated Universal Time)&#39;,<br>    userName: &#39;Jimbo&#39;,<br>    storyBody: &#39;another random story&#39;<br>  }<br>]</pre><p name="5bba" id="5bba" class="graf graf--p graf-after--pre">Our <code class="markup--code markup--p-code">map</code> in the code above is an object in which the keys are the properties of the object we wish to transform. The <code class="markup--code markup--p-code">key</code> and <code class="markup--code markup--p-code">transform</code> properties tell our mapper the new name of the object’s key and how we will transform the value of the object passed in, respectively.</p><p name="d637" id="d637" class="graf graf--p graf-after--p">Now we simply pass our <code class="markup--code markup--p-code">map</code> to the <code class="markup--code markup--p-code">mapper</code> library with the object we want transformed and voila! Our new and improved object has proper name casing, properties that match the JS naming convention and a real date instead of a string.</p><p name="aa1c" id="aa1c" class="graf graf--p graf-after--p graf--trailing">So next time your database schema changes or you switch data providers, you may want to consider object-mapper as a means to keep your front-end happy and maintain data sanity.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@brianjenney" class="p-author h-card">Brian Jenney</a> on <a href="https://medium.com/p/bf8e734678f9"><time class="dt-published" datetime="2020-07-06T21:51:48.140Z">July 6, 2020</time></a>.</p><p><a href="https://medium.com/@brianjenney/using-object-mapper-to-format-your-api-data-and-maintain-consistency-bf8e734678f9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 30, 2025.</p></footer></article></body></html>