<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Using Truth Tables to Write Better Unit Tests</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Using Truth Tables to Write Better Unit Tests</h1>
</header>
<section data-field="subtitle" class="p-summary">
A few years ago, I was working at a small startup that was heavy into testing which was a huge mental shift for me, as I had spent the…
</section>
<section data-field="body" class="e-content">
<section name="4eaa" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9eae" id="9eae" class="graf graf--h3 graf--leading graf--title">Using Truth Tables to Write Better Unit Tests</h3><figure name="53e8" id="53e8" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*DpTsflVBBHOa0cGBoVskaQ.jpeg" data-width="553" data-height="484" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*DpTsflVBBHOa0cGBoVskaQ.jpeg"><figcaption class="imageCaption">Outside of alien conspiracy theories — this guy is a big advocate of writing unit tests with truth tables</figcaption></figure><p name="5567" id="5567" class="graf graf--p graf-after--figure">A few years ago, I was working at a small startup that was heavy into testing which was a huge mental shift for me, as I had spent the last two years at a much larger company writing somewhere around 0 tests. Yup, my previous company relied on a QA team to painstakingly test all the scenarios of user behavior we could dream up before shipping our code into the wild. Surprisingly, this worked for the most part.</p><p name="a517" id="a517" class="graf graf--p graf-after--p">While not writing tests certainly made development faster (initially at least), unit tests are the standard at most modern tech companies and now I found myself struggling not only with the syntax for writing unit and integration tests, but the entire idea was so foreign I often didn’t know where to begin. When testing a component or method that could have many permutations, my tests would look something like this:</p><pre name="d458" id="d458" class="graf graf--pre graf-after--p">//coolMethod.js</pre><pre name="dced" id="dced" class="graf graf--pre graf-after--pre">const maybeTruncate = (word, length = 5) =&gt; {</pre><pre name="6b6f" id="6b6f" class="graf graf--pre graf-after--pre">  if(!word.length){</pre><pre name="4d14" id="4d14" class="graf graf--pre graf-after--pre">    return &#39;N/A&#39;;</pre><pre name="2edb" id="2edb" class="graf graf--pre graf-after--pre">  }</pre><pre name="f888" id="f888" class="graf graf--pre graf-after--pre">  return word.length &gt; length ? `${word.slice(0, length)}...` : word;</pre><pre name="8f1b" id="8f1b" class="graf graf--pre graf-after--pre">}</pre><pre name="8775" id="8775" class="graf graf--pre graf-after--pre"><br>//coolMethod.spec.js</pre><pre name="4bdf" id="4bdf" class="graf graf--pre graf-after--pre">it(&#39;supports long words&#39;, () =&gt; {</pre><pre name="c668" id="c668" class="graf graf--pre graf-after--pre">  expect(maybeTruncate(&#39;really big word&#39;)).to.equal(&#39;reall...&#39;)</pre><pre name="514c" id="514c" class="graf graf--pre graf-after--pre">})</pre><pre name="2109" id="2109" class="graf graf--pre graf-after--pre">it(&#39;supports short words&#39;, () =&gt; {</pre><pre name="81b4" id="81b4" class="graf graf--pre graf-after--pre">  expect(maybeTruncate(&#39;short&#39;)).to.equal(&#39;short&#39;)</pre><pre name="06d0" id="06d0" class="graf graf--pre graf-after--pre">})</pre><pre name="fea8" id="fea8" class="graf graf--pre graf-after--pre">it(&#39;supports custom length&#39;, () =&gt; {</pre><pre name="8964" id="8964" class="graf graf--pre graf-after--pre">  expect(maybeTruncate(&#39;kinda big&#39;, 10)).to.equal(&#39;kinda big&#39;)</pre><pre name="d5b6" id="d5b6" class="graf graf--pre graf-after--pre">})</pre><pre name="0528" id="0528" class="graf graf--pre graf-after--pre">it(&#39;supports no word&#39;, () =&gt; {</pre><pre name="6194" id="6194" class="graf graf--pre graf-after--pre">  expect(maybeTruncate(&#39;&#39;)).to.equal(&#39;N/A&#39;)</pre><pre name="0326" id="0326" class="graf graf--pre graf-after--pre">})</pre><p name="187f" id="187f" class="graf graf--p graf-after--pre">A wise developer on my team reviewed my code one day, and looking at a test similar to the one above, offered me some good advice: ‘Stop writing tests like that you fool’ or something to that effect. He was a bit eccentric, even by software developer standards. He then opened his magical bag of coding tricks and showed me the way he wrote tests.</p><p name="2d43" id="2d43" class="graf graf--p graf-after--p">Now this wise guy was particularly suited to offer testing advice as he had written a popular library for EmberJS developers to mock data and this small nugget of testing knowledge he shared with me has stuck with me since.</p><h4 name="6918" id="6918" class="graf graf--h4 graf-after--p">Using Truth Tables</h4><p name="1c67" id="1c67" class="graf graf--p graf-after--h4">A truth table is usually used in Boolean Algebra to express the mathematical outcome produced from a combination of values. We can apply this same logic to creating tests by writing a set of conditions and the expected outcome. This not only makes our code easier to reason about, it also makes more concise tests that can be easily modified to add different conditions to test when our function or component inevitably changes.</p><p name="91f7" id="91f7" class="graf graf--p graf-after--p">Refactoring the above test to use truth tables would look something like this:</p><pre name="1910" id="1910" class="graf graf--pre graf-after--p">const tests = [<br>  //test              word              length      expected<br>  [&#39;no word&#39;,         &#39;&#39;,               undefined,  &#39;N/A&#39;],<br>  [&#39;short word&#39;,     &#39;Short&#39;,           undefined,  &#39;Short&#39;],<br>  [&#39;long word&#39;,      &#39;Not so short&#39;,    undefined,  &#39;Not s...&#39;],<br>  [&#39;custom length&#39;,  &#39;Not short&#39;,       15,         &#39;Not short&#39;],<br>]</pre><pre name="6561" id="6561" class="graf graf--pre graf-after--pre">test.forEach((test) =&gt; {<br>  const [assertion, word, length, expected] = test;  <br>  it(`supports ${assertion}`, () =&gt; {<br>    expect(maybeTruncate(word, length)).to.equal(expected)<br>  })<br>})</pre><p name="d645" id="d645" class="graf graf--p graf-after--pre">Now, when a new scenario needs to be tested, it’s as simple as inserting some values to our truth table and letting our test suite run its course. This cuts down on boilerplate code and overly verbose tests and also explicitly defines the input possibilities we should be aware of instead of searching through a set of tests to find weird edge cases.</p><h4 name="390d" id="390d" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="5321" id="5321" class="graf graf--p graf-after--h4">Writing tests is an art form in itself and although I initially didn’t see the value in them, I’ve come to appreciate how they catch scenarios I didn’t initially prepare for and also can make you feel a lot more comfortable when refactoring code that isn’t yours.</p><p name="cc35" id="cc35" class="graf graf--p graf-after--p graf--trailing">A strong test suite with good coverage can make you more confident that your change on line 183 in a five year old file didn’t break something further down the pipeline. Truth tables are hopefully a pattern you can use to make your tests more concise, explicit and perhaps more importantly, more fun to write.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@brianjenney" class="p-author h-card">Brian Jenney</a> on <a href="https://medium.com/p/dd187f4a08e6"><time class="dt-published" datetime="2020-05-18T19:52:27.031Z">May 18, 2020</time></a>.</p><p><a href="https://medium.com/@brianjenney/using-truth-tables-to-write-better-unit-tests-dd187f4a08e6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 30, 2025.</p></footer></article></body></html>