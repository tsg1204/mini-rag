<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Finally, an Article About Recursion in Javascript That Doesnâ€™t Use Fibonacci</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Finally, an Article About Recursion in Javascript That Doesnâ€™t Use Fibonacci</h1>
</header>
<section data-field="subtitle" class="p-summary">
I am going to try my best not to use any played out jokes regarding recursion in this piece, but being well into my career as a fatherâ€¦
</section>
<section data-field="body" class="e-content">
<section name="e35d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7c48" id="7c48" class="graf graf--h3 graf--leading graf--title">Finally, an Article About Recursion in Javascript That Doesnâ€™t Use Fibonacci</h3><figure name="fa09" id="fa09" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*pYRIii0RYRC4ZxJOsduwKA.jpeg" data-width="1736" data-height="3094" data-is-featured="true" alt="recursive functions in javascript" src="https://cdn-images-1.medium.com/max/800/1*pYRIii0RYRC4ZxJOsduwKA.jpeg"></figure><p name="6d76" id="6d76" class="graf graf--p graf-after--figure">I am going to try my best not to use any played out jokes regarding recursion in this piece, but being well into my career as a father, there are no guarantees.</p><p name="3be2" id="3be2" class="graf graf--p graf-after--p">The idea of recursion is actually pretty simple: a function that calls itself. Now, putting this principle in practice to write something useful is another bag of beans. Letâ€™s take a look at the function below, which is technically recursive but is missing a very important ingredient:</p><pre name="ec8f" id="ec8f" class="graf graf--pre graf-after--p">const countDown = (num) =&gt; {<br>  console.log(num);  <br>  countDown(num - 1);<br>}</pre><pre name="09dd" id="09dd" class="graf graf--pre graf-after--pre">countDown(10);</pre><pre name="1c1e" id="1c1e" class="graf graf--pre graf-after--pre">// 10<br>// 9<br>// 8<br>// 7<br>//...</pre><p name="20fe" id="20fe" class="graf graf--p graf-after--pre">Try running this function in an online editor like <a href="https://repl.it/" data-href="https://repl.it/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repl.it</a> and see what happensâ€¦ go on try it. This <code class="markup--code markup--p-code">countDown</code> function takes in an initial number and, well, counts down. Each successive call decreases the number and logs it to our console. The only problem is there is no end to this recursion!</p><p name="3782" id="3782" class="graf graf--p graf-after--p">If you actually executed this method in the browser you would create a stack overflow. This particular error gives us some insight into what actually happens in the browser API when you write a recursive function using Javascript.</p><p name="42c7" id="42c7" class="graf graf--p graf-after--p">A stack is a data structure that the browser uses to keep track of called functions, once the function is ready to be invoked, it is popped off the call stack. You can think of the stack data structure as a stack of plates, where the last plate on the stack will be the first to be taken off, conversely, a queue data structure is similar to a line to a concert, where the first person in line will be the first inside.</p><p name="00e0" id="00e0" class="graf graf--p graf-after--p">The stack can only handle so many functions being heaped on it until it falls over like some comically tall stack of plates being carried by a waiter. Recursion fail.</p><p name="02e0" id="02e0" class="graf graf--p graf-after--p">Our useless recursive function is missing a base case. A (good) recursive function requires a recursive condition and a base condition. The recursive condition triggers another call of the function while the base case returns from the function, popping it off the stack.</p><pre name="2253" id="2253" class="graf graf--pre graf-after--p">const countDown = (num) =&gt; {<br>  console.log(num);<br>  //base case  <br>  if(num &lt; 1){<br>    return<br>  }  <br>  //recursive case <br>  countDown(num - 1);<br>}</pre><pre name="2941" id="2941" class="graf graf--pre graf-after--pre">countDown(10);</pre><pre name="67a7" id="67a7" class="graf graf--pre graf-after--pre">// 10<br>// 9<br>// 8<br>// 7<br>//...</pre><p name="77c5" id="77c5" class="graf graf--p graf-after--pre">Letâ€™s explore a much more useful problem that can be solved with recursion:</p><pre name="3348" id="3348" class="graf graf--pre graf-after--p">const array =[[1,2,3, [4,5,6]], [7,8,9, [10, [11, 12]]]]</pre><pre name="3b5d" id="3b5d" class="graf graf--pre graf-after--pre">const flattenArray = (arr) =&gt; {</pre><pre name="310d" id="310d" class="graf graf--pre graf-after--pre">  const newArr = [];</pre><pre name="845e" id="845e" class="graf graf--pre graf-after--pre">  arr.forEach((item) =&gt; {<br>    if(Array.isArray(item)){<br>      // recursive case  <br>      newArr.push(...flattenArray(item))<br>    }else{<br>      //base case<br>      newArr.push(item)<br>    }<br>  })<br>  return newArr;<br>}</pre><pre name="a1cf" id="a1cf" class="graf graf--pre graf-after--pre">flattenArray(array);</pre><p name="3a2e" id="3a2e" class="graf graf--p graf-after--pre">The aptly named <code class="markup--code markup--p-code">flattenArray</code> does exactly what its name suggests: it flattens a freakinâ€™ array! We pass in an array with some unknown amount of nested arrays, nested at different levels and return a single array with all the items included.</p><p name="7c88" id="7c88" class="graf graf--p graf-after--p">This kind of problem immediately strikes me as one that should be solved via recursion as we do not know how many nested arrays may be included in the argument or how deeply nested they may be. A for loop wonâ€™t satisfy our needs here but we will definitely be solving the same problem many times overâ€Šâ€”â€Šsolving the same problem many times you say? Recursion should be your first thought now as well.</p><p name="75bf" id="75bf" class="graf graf--p graf-after--p">Any problem that can be solved recursively can also be solved iteratively, often by using a work queue and a while loop. The reason we often choose to use recursion over an iterative solution is for readability and ease of use. A recursive solution is often just simpler to write.</p><p name="0080" id="0080" class="graf graf--p graf-after--p">Looking back at our <code class="markup--code markup--p-code">flattenArray</code> method, we see there are only two cases we supportâ€Šâ€”â€Šif the item we are looking at is an array or not. If the current item is an array, we recursively call our function and push the destructured result to our final array. If the item is not an array, we simply push it to our final array.</p><p name="6b66" id="6b66" class="graf graf--p graf-after--p">When you begin writing recursive functions, it can be tempting to think through each call to understand what is happening at every iteration. I personally find this confusing and perhaps you will too. My advice is to break the problem you are attempting to solve down to its most trivial form. For example, in the problem above, we only care if the item is an array or notâ€Šâ€”â€Šif not, letâ€™s flatten it.</p><p name="a2e8" id="a2e8" class="graf graf--p graf-after--p">This approach of determining the simplest subproblem requires a bit of faith that recursion will just work and it will take a while to build that confidence. The more problems you solve with recursion, the more you will get a feel for when and where to use it.</p><p name="e1d5" id="e1d5" class="graf graf--p graf-after--p">If you just HAVE to see whatâ€™s happening at each iteration, feel free to add a <code class="markup--code markup--p-code">debugger</code> statement above the recursive case and you can check call stack in the browser to get a more in depth view of the current values in the local scope and watch the call stack grow:</p><figure name="322a" id="322a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CX4Xs-R7T_W6Zz35eqM2Cg.png" data-width="2406" data-height="602" src="https://cdn-images-1.medium.com/max/800/1*CX4Xs-R7T_W6Zz35eqM2Cg.png"></figure><p name="a91d" id="a91d" class="graf graf--p graf-after--figure">Donâ€™t be scared of recursion. Itâ€™s yet another tool in your developer tool box and it can help you solve complex problems you may encounter at work and almost certainly in any interview for a highly coveted tech company ðŸ˜‰.</p><p name="24b1" id="24b1" class="graf graf--p graf-after--p">If you want more practice solving recursive problems, head over to <a href="https://leetcode.com/tag/recursion/" data-href="https://leetcode.com/tag/recursion/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LeetCode</a> and check out their list of head scratchers.</p><p name="2629" id="2629" class="graf graf--p graf-after--p graf--trailing">If you want to learn more about recursion, read this article: <a href="https://brianjenney.medium.com/finally-an-article-about-recursion-in-javascript-that-doesnt-use-fibonacci-ca5963b11e3b" data-href="https://brianjenney.medium.com/finally-an-article-about-recursion-in-javascript-that-doesnt-use-fibonacci-ca5963b11e3b" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Finally, an Article About Recursion in Javascript That Doesnâ€™t Use Fibonacci</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@brianjenney" class="p-author h-card">Brian Jenney</a> on <a href="https://medium.com/p/ca5963b11e3b"><time class="dt-published" datetime="2020-12-12T14:20:02.018Z">December 12, 2020</time></a>.</p><p><a href="https://medium.com/@brianjenney/finally-an-article-about-recursion-in-javascript-that-doesnt-use-fibonacci-ca5963b11e3b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 30, 2025.</p></footer></article></body></html>