<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Using Inversion of Control to Write More Easily Testable React Components</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Using Inversion of Control to Write More Easily Testable React Components</h1>
</header>
<section data-field="subtitle" class="p-summary">
Have you ever written a fairly simple React component only to get bogged down in complicated tests? üôã
</section>
<section data-field="body" class="e-content">
<section name="2afc" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="600c" id="600c" class="graf graf--h3 graf--leading graf--title">Using Inversion of Control to Write More Easily Testable React Components</h3><figure name="350d" id="350d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*v01LygAgEIEsil3JKmqj0A.jpeg" data-width="1280" data-height="720" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*v01LygAgEIEsil3JKmqj0A.jpeg"></figure><p name="6f3a" id="6f3a" class="graf graf--p graf-after--figure">Have you ever written a fairly simple React component only to get bogged down in complicated tests? üôã</p><p name="6d92" id="6d92" class="graf graf--p graf-after--p">It may start like this‚Ää‚Äî‚Ääyou create a simple shopping cart component for an e-commerce site. Someone from marketing only wants logged in users to see a certain visual display. Ok no prob. The backend team makes a change to the API for ordering items‚Ää‚Äî‚Äänow logged in customers must call a different endpoint. No big deal, you simply add in a condition to determine which url to use.</p><p name="1d82" id="1d82" class="graf graf--p graf-after--p">Inevitably, this will not be the last request for changes to your ‚Äúsimple‚Äù component. But you leave that for your future self to figure out üòâ.</p><p name="d269" id="d269" class="graf graf--p graf-after--p">Your component works! Now it‚Äôs just a matter of writing tests to maintain your team‚Äôs test coverage threshold. You realize you now need to mock the redux store in order for the test component to grab the logged in state as well as the http request library you are using üòÖ. You shake your fist in anger at your past self. How could you you, you whisper, looking in the mirror.</p><p name="d20e" id="d20e" class="graf graf--p graf-after--p">Your current component looks something like this:</p><figure name="6392" id="6392" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/BrianJenney/59122a03111a499ccda2d091beee2117.js"></script></figure><p name="f8d8" id="f8d8" class="graf graf--p graf-after--figure">Using the principle of Inversion of Control we can create some abstractions on top of our http client <code class="markup--code markup--p-code">axios</code> and use a container to implement the <code class="markup--code markup--p-code">addToCartFunction</code> for our <code class="markup--code markup--p-code">ShoppingCart</code>. Inversion of Control is a principle for composing software which basically offloads the implementation of custom logic outside the class or in this case the component where it is being used.</p><blockquote name="d3fc" id="d3fc" class="graf graf--blockquote graf-after--p">In IoC, custom-written portions of a computer program receive the flow of control from a generic framework.‚Ää‚Äî‚Ää<a href="https://en.wikipedia.org/wiki/Inversion_of_control" data-href="https://en.wikipedia.org/wiki/Inversion_of_control" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--blockquote-em">Wikipedia</em></a></blockquote><figure name="4c40" id="4c40" class="graf graf--figure graf--iframe graf-after--blockquote"><script src="https://gist.github.com/BrianJenney/e12193cddd68b661df10282f79985281.js"></script></figure><p name="8e8d" id="8e8d" class="graf graf--p graf-after--figure">In the example above we have made some significant refactoring to our original <code class="markup--code markup--p-code">ShoppingCart</code> component.</p><p name="ff8b" id="ff8b" class="graf graf--p graf-after--p">We have now implemented a <code class="markup--code markup--p-code">ShoppingCartContainer</code> to act as a dependency injection container and will take care of the actual implementation of our <code class="markup--code markup--p-code">addToCartFunction</code>. We have also abstracted away the direct call to a 3rd party library <code class="markup--code markup--p-code">axios</code> and replaced it with a generic <code class="markup--code markup--p-code">apiClient</code> class to handle http requests.</p><p name="68e2" id="68e2" class="graf graf--p graf-after--p">A unit test can now handle the implementation of <code class="markup--code markup--p-code">apiClient</code> and it becomes trivial to mock or stub it and ensure it is called with the correct arguments using library like <code class="markup--code markup--p-code">jest</code>.</p><p name="43d8" id="43d8" class="graf graf--p graf-after--p graf--trailing"><code class="markup--code markup--p-code">ShoppingCart</code> no longer implements <code class="markup--code markup--p-code">addToCartFunction</code> and can be used in a different context with a different function. Now when a new use case is introduced for the cart‚Ää‚Äî‚Ääwe can simply pass in a different function rather than appending more logic and increasing cyclomatic complexity.</p></div></div></section><section name="4d02" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="5929" id="5929" class="graf graf--p graf--leading graf--trailing">It‚Äôs frustrating to finally ‚Äúfinish‚Äù a component or large feature only to begin writing tests and realize you have coded yourself into a corner. Using paradigms like Inversion of Control and Dependency Injection can offer some patterns to reduce the complexity of your tests and create components that are more flexible and modular.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@brianjenney" class="p-author h-card">Brian Jenney</a> on <a href="https://medium.com/p/ffa0248822ee"><time class="dt-published" datetime="2021-11-29T14:39:40.906Z">November 29, 2021</time></a>.</p><p><a href="https://medium.com/@brianjenney/using-inversion-of-control-to-write-more-easily-testable-react-components-ffa0248822ee" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 30, 2025.</p></footer></article></body></html>